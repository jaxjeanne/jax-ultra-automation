/// <reference types="node" />
/// <reference types="expect-webdriverio/types/expect-webdriverio" />
import Jasmine from 'jasmine';
import { EventEmitter } from 'events';
import type { Options, Services, Capabilities } from '@wdio/types';
import type { JasmineOpts as jasmineNodeOpts, ResultHandlerPayload, FrameworkMessage, FormattedMessage } from './types';
type HooksArray = {
    [K in keyof Required<Services.HookFunctions>]: Required<Services.HookFunctions>[K][];
};
interface WebdriverIOJasmineConfig extends Omit<Options.Testrunner, keyof HooksArray>, HooksArray {
    jasmineOpts: Omit<jasmineNodeOpts, 'cleanStack'>;
}
/**
 * Jasmine runner
 */
declare class JasmineAdapter {
    private _cid;
    private _config;
    private _specs;
    private _capabilities;
    private _jasmineOpts;
    private _reporter;
    private _totalTests;
    private _hasTests;
    private _lastTest?;
    private _lastSpec?;
    private _jrunner?;
    constructor(_cid: string, _config: WebdriverIOJasmineConfig, _specs: string[], _capabilities: Capabilities.RemoteCapabilities, reporter: EventEmitter);
    init(): Promise<this>;
    _loadFiles(): void;
    _grep(suite: jasmine.Suite): void;
    hasTests(): boolean;
    run(): Promise<unknown>;
    customSpecFilter(spec: jasmine.Spec): boolean;
    /**
     * Hooks which are added as true Jasmine hooks need to call done() to notify async
     */
    wrapHook(hookName: keyof Services.HookFunctions): () => Promise<void | unknown[]>;
    prepareMessage(hookName: keyof Services.HookFunctions): FormattedMessage;
    formatMessage(params: FrameworkMessage): FormattedMessage;
    getExpectationResultHandler(jasmine: jasmine.Jasmine): any;
    expectationResultHandler(origHandler: Function): (this: jasmine.Spec, passed: boolean, data: ResultHandlerPayload) => any;
}
declare const adapterFactory: {
    init?: Function;
};
export default adapterFactory;
export { JasmineAdapter, adapterFactory };
export * from './types';
type jasmine = typeof Jasmine;
declare global {
    /**
     * Define a single spec. A spec should contain one or more expectations that test the state of the code.
     * A spec whose expectations all succeed will be passing and a spec with any failures will fail.
     * @param expectation Textual description of what this spec is checking
     * @param assertion Function that contains the code of your test. If not provided the test will be pending.
     * @param timeout Custom timeout for an async spec.
     * @param retries Custom retry count for this single spec (WebdriverIO specific)
     */
    function it(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * A focused `it`. If suites or specs are focused, only those that are focused will be executed.
     * @param expectation Textual description of what this spec is checking
     * @param assertion Function that contains the code of your test. If not provided the test will be pending.
     * @param timeout Custom timeout for an async spec.
     * @param retries Custom retry count for this single spec (WebdriverIO specific)
     */
    function fit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * A temporarily disabled `it`. The spec will report as pending and will not be executed.
     * @param expectation Textual description of what this spec is checking
     * @param assertion Function that contains the code of your test. If not provided the test will be pending.
     * @param timeout Custom timeout for an async spec.
     * @param retries Custom retry count for this single spec (WebdriverIO specific)
     */
    function xit(expectation: string, assertion?: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * Run some shared setup before each of the specs in the describe in which it is called.
     * @param action Function that contains the code to setup your specs.
     * @param timeout Custom timeout for an async beforeEach.
     * @param retries Custom retry count for this single hook (WebdriverIO specific)
     */
    function beforeEach(action: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * Run some shared teardown after each of the specs in the describe in which it is called.
     * @param action Function that contains the code to teardown your specs.
     * @param timeout Custom timeout for an async afterEach.
     * @param retries Custom retry count for this single hook (WebdriverIO specific)
     */
    function afterEach(action: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * Run some shared setup once before all of the specs in the describe are run.
     * Note: Be careful, sharing the setup from a beforeAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @param action Function that contains the code to setup your specs.
     * @param timeout Custom timeout for an async beforeAll.
     * @param retries Custom retry count for this single hook (WebdriverIO specific)
     */
    function beforeAll(action: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    /**
     * Run some shared teardown once before all of the specs in the describe are run.
     * Note: Be careful, sharing the teardown from a afterAll makes it easy to accidentally leak state between your specs so that they erroneously pass or fail.
     * @param action Function that contains the code to teardown your specs.
     * @param timeout Custom timeout for an async afterAll
     * @param retries Custom retry count for this single hook (WebdriverIO specific)
     */
    function afterAll(action: jasmine.ImplementationCallback, timeout?: number, retries?: number): void;
    namespace WebdriverIO {
        interface JasmineOpts extends jasmineNodeOpts {
        }
    }
    namespace jasmine {
        interface Matchers<T> extends ExpectWebdriverIO.Matchers<any, T> {
        }
        interface AsyncMatchers<T, U> extends ExpectWebdriverIO.Matchers<Promise<void>, T> {
        }
    }
}
//# sourceMappingURL=index.d.ts.map